"use strict";(self.webpackChunkclematis_doc=self.webpackChunkclematis_doc||[]).push([[5248],{98451:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"recipe-book/java/maths","title":"Math Operations","description":"Modular exponentiation","source":"@site/docs/recipe-book/java/maths.md","sourceDirName":"recipe-book/java","slug":"/recipe-book/java/maths","permalink":"/clematis.doc/docs/recipe-book/java/maths","draft":false,"unlisted":false,"tags":[{"inline":true,"label":"hashmap","permalink":"/clematis.doc/docs/tags/hashmap"},{"inline":true,"label":"hashset","permalink":"/clematis.doc/docs/tags/hashset"}],"version":"current","lastUpdatedAt":1762943897000,"frontMatter":{"tags":["hashmap","hashset"]},"sidebar":"tutorialSidebar","previous":{"title":"Maps And Sets","permalink":"/clematis.doc/docs/recipe-book/java/map"},"next":{"title":"Prefix Sum","permalink":"/clematis.doc/docs/recipe-book/java/prefix_sum"}}');var i=t(74848),s=t(28453);const o={tags:["hashmap","hashset"]},r="Math Operations",l={},c=[{value:"Modular exponentiation",id:"modular-exponentiation",level:2},{value:"GCD",id:"gcd",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"math-operations",children:"Math Operations"})}),"\n",(0,i.jsx)(n.h2,{id:"modular-exponentiation",children:"Modular exponentiation"}),"\n",(0,i.jsxs)(n.p,{children:['The implementation of modular exponentiation\n(also known as "binary exponentiation" or "fast power modulo").\nIt efficiently computes ',(0,i.jsx)(n.code,{children:"(a^b) % mod"})," for large values of a and b without causing integer overflow."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"    long res = 1;\n    a %= mod;\n    while (b > 0) {\n        if ((b & 1) == 1) { // if b is odd\n            res = (res * a) % mod; // extra multiplication for b to become even\n        }\n        a = (a * a) % mod; // get a square\n        b >>= 1; // divide by two \n    }\n    return res;\n"})}),"\n",(0,i.jsx)(n.p,{children:"How it works:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"The variable res is initialized to 1."}),"\n",(0,i.jsx)(n.li,{children:"While b > 0, it checks if the lowest bit of b is set (i.e., if b is odd). If so, it multiplies res by a modulo mod."}),"\n",(0,i.jsx)(n.li,{children:"Then, a is squared modulo mod and b is shifted right by 1 (divided by 2)."}),"\n",(0,i.jsx)(n.li,{children:"This repeats until b becomes 0."}),"\n",(0,i.jsx)(n.li,{children:"The result is returned."}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"gcd",children:"GCD"}),"\n",(0,i.jsx)(n.p,{children:"Greatest common divisor of two numbers:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"int gcd(int a, int b) {\n    if (b == 0) {\n        return a;\n    }\n    return gcd(b, a % b);\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"The same without recursion:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"    static int gcd(int a, int b) {\n        a = Math.abs(a);\n        b = Math.abs(b);\n        if (a == 0) {\n            return b;\n        }\n        if (b == 0) {\n            return a;\n        }\n        while (b != 0) {\n            int t = a % b;\n            a = b;\n            b = t;\n        }\n        return a;\n    }\n"})})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>r});var a=t(96540);const i={},s=a.createContext(i);function o(e){const n=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),a.createElement(s.Provider,{value:n},e.children)}}}]);