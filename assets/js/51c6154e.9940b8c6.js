"use strict";(self.webpackChunkclematis_doc=self.webpackChunkclematis_doc||[]).push([[3293],{18876:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"recipe-book/java/arrays","title":"Arrays","description":"Monotonic Stack Pattern","source":"@site/docs/recipe-book/java/arrays.md","sourceDirName":"recipe-book/java","slug":"/recipe-book/java/arrays","permalink":"/clematis.doc/docs/recipe-book/java/arrays","draft":false,"unlisted":false,"tags":[{"inline":true,"label":"arrays","permalink":"/clematis.doc/docs/tags/arrays"},{"inline":true,"label":"algorithms","permalink":"/clematis.doc/docs/tags/algorithms"}],"version":"current","lastUpdatedAt":1762432524000,"frontMatter":{"tags":["arrays","algorithms"]},"sidebar":"tutorialSidebar","previous":{"title":"Java"},"next":{"title":"Binary Search","permalink":"/clematis.doc/docs/recipe-book/java/binary_search"}}');var a=t(74848),s=t(28453);const i={tags:["arrays","algorithms"]},o="Arrays",l={},c=[{value:"Monotonic Stack Pattern",id:"monotonic-stack-pattern",level:2},{value:"Next Smaller Element To The Right",id:"next-smaller-element-to-the-right",level:3}];function h(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"arrays",children:"Arrays"})}),"\n",(0,a.jsx)(n.h2,{id:"monotonic-stack-pattern",children:"Monotonic Stack Pattern"}),"\n",(0,a.jsx)(n.h3,{id:"next-smaller-element-to-the-right",children:"Next Smaller Element To The Right"}),"\n",(0,a.jsx)(n.p,{children:"How it works"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"For each element in the array, find the index of the next smaller element to its right.\nIf none exists, return -1."}),"\n",(0,a.jsx)(n.li,{children:"Go through the array."}),"\n",(0,a.jsxs)(n.li,{children:["Maintain a stack of indices whose next smaller element has not been found yet.","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"The stack is monotonic increasing, meaning the elements corresponding to the\nindices in the stack increase from bottom to top."}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["For the current element arr[r]:","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["While the stack is not empty, and the element at the top of the stack is greater than arr[r]:","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"We have found the next smaller element for arr[stack.peek()]."}),"\n",(0,a.jsx)(n.li,{children:"Set result[stack.pop()] = r."}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.li,{children:"Push the current index r onto the stack for future comparison."}),"\n",(0,a.jsx)(n.li,{children:"After the loop finishes, any indices remaining in the stack have\nno smaller element to the right, so they remain -1."}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"int[] nextSmaller(int[] arr) {\n    int[] result = new int[arr.length]; \n    Arrays.fill(result, -1);\n\n    Deque<Integer> stack = new ArrayDeque<>();\n    int r = 0;\n\n    while (r < arr.length) {\n        int a = arr[r];\n        while (!stack.isEmpty() && arr[stack.peek()] > a) {\n            result[stack.peek()] = r;\n            stack.pop();\n        }\n        stack.push(r);\n        r++;\n    }\n\n    return result;\n}\n"})})]})}function d(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>o});var r=t(96540);const a={},s=r.createContext(a);function i(e){const n=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);