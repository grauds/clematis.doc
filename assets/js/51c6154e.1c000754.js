"use strict";(self.webpackChunkclematis_doc=self.webpackChunkclematis_doc||[]).push([[3293],{18876:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>m,frontMatter:()=>s,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"recipe-book/java/arrays","title":"Arrays","description":"Monotonic Stack Pattern","source":"@site/docs/recipe-book/java/arrays.md","sourceDirName":"recipe-book/java","slug":"/recipe-book/java/arrays","permalink":"/clematis.doc/docs/recipe-book/java/arrays","draft":false,"unlisted":false,"tags":[{"inline":true,"label":"arrays","permalink":"/clematis.doc/docs/tags/arrays"},{"inline":true,"label":"algorithms","permalink":"/clematis.doc/docs/tags/algorithms"}],"version":"current","lastUpdatedAt":1762442102000,"frontMatter":{"tags":["arrays","algorithms"]},"sidebar":"tutorialSidebar","previous":{"title":"Java"},"next":{"title":"Binary Search","permalink":"/clematis.doc/docs/recipe-book/java/binary_search"}}');var i=t(74848),a=t(28453);const s={tags:["arrays","algorithms"]},o="Arrays",l={},c=[{value:"Monotonic Stack Pattern",id:"monotonic-stack-pattern",level:2},{value:"Next Smaller Element To The Right",id:"next-smaller-element-to-the-right",level:3},{value:"Minimum In The Moving Window",id:"minimum-in-the-moving-window",level:3}];function h(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"arrays",children:"Arrays"})}),"\n",(0,i.jsx)(n.h2,{id:"monotonic-stack-pattern",children:"Monotonic Stack Pattern"}),"\n",(0,i.jsx)(n.h3,{id:"next-smaller-element-to-the-right",children:"Next Smaller Element To The Right"}),"\n",(0,i.jsx)(n.p,{children:"How it works"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"For each element in the array, find the index of the next smaller element to its right.\nIf none exists, return -1."}),"\n",(0,i.jsx)(n.li,{children:"Go through the array."}),"\n",(0,i.jsxs)(n.li,{children:["Maintain a stack of indices whose next smaller element has not been found yet.","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"The stack is monotonic increasing, meaning the elements corresponding to the\nindices in the stack increase from bottom to top."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["For the current element arr[r]:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["While the stack is not empty, and the element at the top of the stack is greater than arr[r]:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"We have found the next smaller element for arr[stack.peek()]."}),"\n",(0,i.jsx)(n.li,{children:"Set result[stack.pop()] = r."}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.li,{children:"Push the current index r onto the stack for future comparison."}),"\n",(0,i.jsx)(n.li,{children:"After the loop finishes, any indices remaining in the stack have\nno smaller element to the right, so they remain -1."}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"int[] nextSmaller(int[] arr) {\n    int[] result = new int[arr.length]; \n    Arrays.fill(result, -1);\n\n    Deque<Integer> stack = new ArrayDeque<>();\n    int r = 0;\n\n    while (r < arr.length) {\n        int a = arr[r];\n        \n        // While the current element 'a' is smaller than the element corresponding\n        // to the index on the top of the stack, it means we have found\n        // the next smaller element for that index.\n        while (!stack.isEmpty() && arr[stack.peek()] > a) {\n            result[stack.peek()] = r; // store the index of the next smaller element\n            stack.pop(); // remove that index from the stack\n        }\n        \n        // Push the current index onto the stack to process it later\n        stack.push(r);\n        r++;\n    }\n\n    return result;\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"minimum-in-the-moving-window",children:"Minimum In The Moving Window"}),"\n",(0,i.jsx)(n.p,{children:"The window of size k is moving from the left to the right,\nand we are looking for the minimum element in the window. The key idea is to\ndrop the oldest element from the stack when the window moves while reusing the\nMonotonic Stack Pattern from the previous problem."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"static int[] minInWindow(int[] a, int k) {\n\n    int[] mins = new int[a.length - k + 1];\n    int l = 0;\n    int r = 0;\n    Deque<Integer> stack = new ArrayDeque<>(k);\n\n    while (r < a.length) {\n    \n        // Expand window to size k by adding elements until r == l + k\n        while (r < l + k) {\n            int number = a[r];\n            \n            // Remove all indices from the top whose corresponding values\n            // are greater than the current number \u2014 they can never be a minimum again            \n            while (!stack.isEmpty() && a[stack.peek()] > number) {\n                stack.pop();\n            }\n            \n            // Push current index \u2014 since all bigger ones were removed,\n            // elements in stack are now in non-decreasing order (by value)\n            stack.push(r);\n            \n            r++;\n        }\n\n        // If the stack is not empty, the smallest element\u2019s index is at the *back* (peekLast)\n        if (!stack.isEmpty()) {\n            // Save the minimum for the current window (we have just processed it)\n            mins[l] = a[stack.peekLast()]; // <-- min goes here\n            \n            // Before moving the window, check if the element going out (a[l])\n            // is exactly the minimum stored at the back of the deque.\n            // If so, remove it because it will no longer belong to the next window.\n            if (a[stack.peekLast()] == a[l]) { // we are moving window next, a[l]\n                stack.pollLast();\n            }\n        }\n        \n        // Slide the window one step to the right\n        l++;\n    }\n\n    return mins;\n}\n"})})]})}function m(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>o});var r=t(96540);const i={},a=r.createContext(i);function s(e){const n=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);