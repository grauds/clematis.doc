"use strict";(self.webpackChunkclematis_doc=self.webpackChunkclematis_doc||[]).push([[5248],{98451:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>s,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"recipe-book/java/maths","title":"Math Operations","description":"Modular exponentiation","source":"@site/docs/recipe-book/java/maths.md","sourceDirName":"recipe-book/java","slug":"/recipe-book/java/maths","permalink":"/clematis.doc/docs/recipe-book/java/maths","draft":false,"unlisted":false,"tags":[{"inline":true,"label":"hashmap","permalink":"/clematis.doc/docs/tags/hashmap"},{"inline":true,"label":"hashset","permalink":"/clematis.doc/docs/tags/hashset"}],"version":"current","lastUpdatedAt":1751378696000,"frontMatter":{"tags":["hashmap","hashset"]},"sidebar":"tutorialSidebar","previous":{"title":"Maps And Sets","permalink":"/clematis.doc/docs/recipe-book/java/map"},"next":{"title":"Prefix Sum","permalink":"/clematis.doc/docs/recipe-book/java/prefix_sum"}}');var a=t(74848),o=t(28453);const s={tags:["hashmap","hashset"]},r="Math Operations",l={},c=[{value:"Modular exponentiation",id:"modular-exponentiation",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"math-operations",children:"Math Operations"})}),"\n",(0,a.jsx)(n.h2,{id:"modular-exponentiation",children:"Modular exponentiation"}),"\n",(0,a.jsxs)(n.p,{children:['The implementation of modular exponentiation\n(also known as "binary exponentiation" or "fast power modulo").\nIt efficiently computes ',(0,a.jsx)(n.code,{children:"(a^b) % mod"})," for large values of a and b without causing integer overflow."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"    long res = 1;\n    a %= mod;\n    while (b > 0) {\n        if ((b & 1) == 1) { // if b is odd\n            res = (res * a) % mod; // extra multiplication for b to become even\n        }\n        a = (a * a) % mod; // get a square\n        b >>= 1; // divide by two \n    }\n    return res;\n"})}),"\n",(0,a.jsx)(n.p,{children:"How it works:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"The variable res is initialized to 1."}),"\n",(0,a.jsx)(n.li,{children:"While b > 0, it checks if the lowest bit of b is set (i.e., if b is odd). If so, it multiplies res by a modulo mod."}),"\n",(0,a.jsx)(n.li,{children:"Then, a is squared modulo mod and b is shifted right by 1 (divided by 2)."}),"\n",(0,a.jsx)(n.li,{children:"This repeats until b becomes 0."}),"\n",(0,a.jsx)(n.li,{children:"The result is returned."}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>r});var i=t(96540);const a={},o=i.createContext(a);function s(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);